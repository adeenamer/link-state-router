
import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph, find_path


class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        self.graph = Graph(undirected=True)
        self.ftable = {} #this stores the graph as a dictionary
        self.ports = defaultdict(dict) #this stores the port of every nodes connection
        self.seqno = {} #this stores the sequence number of each node
        self.seq_no = 0

       
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        pass


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
           
            if packet.dstAddr in self.ftable:
                try:
                    path = find_path(self.graph, self.addr, packet.dstAddr)

                    por = self.ports[self.addr][path.nodes[1]]
                    self.send(por, packet)
                
                except:
                    pass

        else:
            # this is a routing packet generated by my routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different

            cont = packet.content.split(" ", 1) #cont[0] is the seqno and the rest is the packet
            data = loads(cont[1])

            if packet.srcAddr in self.seqno:
                if cont[0] > self.seqno[packet.srcAddr]: #if seqno is greater than stored and exists in dict

                    self.seqno[packet.srcAddr] = cont[0]   #seqno updated

                    if len(self.ftable[packet.srcAddr])>0:                  
                        if self.ftable[packet.srcAddr]!=data:

                            if len(self.ftable[packet.srcAddr]) < len(data):
                                for x in data:
                                    if x not in self.ftable[packet.srcAddr]:
                                        self.graph.add_edge(packet.srcAddr, x, data[x])

                            elif len(self.ftable[packet.srcAddr]) > len(data):
                                for x in list(self.ftable[packet.srcAddr]):
                                    if x not in data:
                                        self.graph.remove_edge(packet.srcAddr, x)

                        self.ftable = self.graph.get_data() #dict update

                        for x in self.ftable[self.addr]:
                            if x in packet.srcAddr:
                                continue
                            else:
                                p = Packet(Packet.ROUTING, packet.srcAddr, x)
                                p.content = str(self.seqno[packet.srcAddr]) + " " + dumps(self.ftable[packet.srcAddr])
                                try:
                                    por = self.ports[self.addr][x]
                                    self.send(por, p)
                                except:
                                    pass


            else:
                self.seqno[packet.srcAddr] = cont[0]

                for x in data:   #to add the edges to the graph
                    self.graph.add_edge(packet.srcAddr, x, data[x])

                self.ftable = self.graph.get_data() #dict update

                for x in self.ftable[self.addr]:
                    if x in packet.srcAddr:
                        continue
                    else:
                        p = Packet(Packet.ROUTING, packet.srcAddr, x)
                        p.content = str(self.seqno[packet.srcAddr]) + " " + dumps(self.ftable[packet.srcAddr])
                        por = self.ports[self.addr][x]
                        self.send(por, p)


            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            pass


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        self.graph.add_edge(self.addr, endpoint, cost)

        self.ports[self.addr][endpoint] = port

        self.ftable = self.graph.get_data()

        for x in self.ftable[self.addr]:
            p = Packet(Packet.ROUTING, self.addr, x)
            p.content = str(self.seq_no) + " " + dumps(self.ftable[self.addr])
            por = self.ports[self.addr][x]
            self.send(por, p)

        self.seq_no +=1

        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        pass


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        for x in self.ports[self.addr]:
            if self.ports[self.addr][x] == port:
                self.graph.remove_edge(self.addr, x)
                del self.ports[self.addr][x]
                self.ftable = self.graph.get_data()
                break


        for y in self.ftable[self.addr]:
            p = Packet(Packet.ROUTING, self.addr, y)
            p.content = str(self.seq_no) + " " + dumps(self.ftable[self.addr])
            por = self.ports[self.addr][y]
            self.send(por, p)

        self.seq_no +=1


        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        pass


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs

            # broadcast the link state of this router to all neighbors
            for x in self.ftable[self.addr]:
                p = Packet(Packet.ROUTING, self.addr, x)
                p.content = str(self.seq_no) + " " + dumps(self.ftable[self.addr])
                try:
                    por = self.ports[self.addr][x]
                    self.send(por, p)
                except:
                    pass

            self.seq_no +=1
            pass


    def debugString(self):
        return ""